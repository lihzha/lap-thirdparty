#!/usr/bin/env python3
"""Visualize RLDS datasets generated by tensorflow_datasets builders."""

import argparse
from pathlib import Path

import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button
import numpy as np
import tensorflow_datasets as tfds


def load_rlds_dataset(dataset_path: str, split: str = "train"):
    """Load an RLDS dataset from the given path."""
    # Load the dataset
    builder = tfds.builder_from_directory(dataset_path)
    ds = builder.as_dataset(split=split)
    return ds


def extract_episode_data(episode) -> dict:
    """Extract all data from a single episode into numpy arrays."""
    images = []
    wrist_images = []
    states = []
    actions = []
    rewards = []
    language_instruction = None
    
    for step in episode['steps']:
        images.append(step['observation']['image'].numpy())
        wrist_images.append(step['observation']['wrist_image'].numpy())
        states.append(step['observation']['state'].numpy())
        actions.append(step['action'].numpy())
        rewards.append(step['reward'].numpy())
        if language_instruction is None:
            language_instruction = step['language_instruction'].numpy().decode('utf-8')
    
    return {
        'images': np.array(images),
        'wrist_images': np.array(wrist_images),
        'states': np.array(states),
        'actions': np.array(actions),
        'rewards': np.array(rewards),
        'language_instruction': language_instruction,
        'file_path': episode['episode_metadata']['file_path'].numpy().decode('utf-8'),
    }


def create_interactive_viewer(episodes: list, dataset_path: str):
    """Create an interactive matplotlib viewer for the dataset."""
    current_episode_idx = [0]
    current_frame = [0]
    
    # Load first episode
    episode_data = [extract_episode_data(episodes[0])]
    
    n_episodes = len(episodes)
    n_frames = len(episode_data[0]['images'])
    
    # Create figure
    fig = plt.figure(figsize=(16, 10))
    fig.suptitle(f'RLDS Dataset: {Path(dataset_path).name}', fontsize=14)
    
    # Image axes
    ax_img = fig.add_subplot(2, 4, 1)
    ax_wrist = fig.add_subplot(2, 4, 2)
    
    # Info panel
    ax_info = fig.add_subplot(2, 4, 3)
    ax_info.axis('off')
    
    # State plots
    ax_state_pos = fig.add_subplot(2, 4, 5)
    ax_state_rot = fig.add_subplot(2, 4, 6)
    ax_action_pos = fig.add_subplot(2, 4, 7)
    ax_action_rot = fig.add_subplot(2, 4, 8)
    
    # Episode info panel
    ax_episode_info = fig.add_subplot(2, 4, 4)
    ax_episode_info.axis('off')
    
    # Initial display
    im_img = ax_img.imshow(episode_data[0]['images'][0])
    ax_img.set_title('External Camera')
    ax_img.axis('off')
    
    im_wrist = ax_wrist.imshow(episode_data[0]['wrist_images'][0])
    ax_wrist.set_title('Wrist Camera')
    ax_wrist.axis('off')
    
    # Info text
    info_text = ax_info.text(0.05, 0.95, '', transform=ax_info.transAxes,
                             fontsize=10, verticalalignment='top',
                             fontfamily='monospace')
    
    episode_info_text = ax_episode_info.text(0.05, 0.95, '', transform=ax_episode_info.transAxes,
                                              fontsize=10, verticalalignment='top',
                                              fontfamily='monospace')
    
    # State position plot lines
    state_pos_lines = []
    action_pos_lines = []
    state_rot_lines = []
    action_rot_lines = []
    state_pos_vline = None
    state_rot_vline = None
    action_pos_vline = None
    action_rot_vline = None
    
    def plot_episode_data(data):
        nonlocal state_pos_lines, action_pos_lines, state_rot_lines, action_rot_lines
        nonlocal state_pos_vline, state_rot_vline, action_pos_vline, action_rot_vline
        
        n = len(data['states'])
        time = np.arange(n)
        
        # Clear axes
        ax_state_pos.clear()
        ax_state_rot.clear()
        ax_action_pos.clear()
        ax_action_rot.clear()
        
        # State position (x, y, z)
        pos_labels = ['x', 'y', 'z']
        for i in range(3):
            ax_state_pos.plot(time, data['states'][:, i], label=pos_labels[i], alpha=0.8)
        state_pos_vline = ax_state_pos.axvline(x=0, color='r', linestyle='--', linewidth=2)
        ax_state_pos.set_xlabel('Step')
        ax_state_pos.set_ylabel('Position')
        ax_state_pos.set_title('State: Position (xyz)')
        ax_state_pos.legend(loc='upper right', fontsize=8)
        ax_state_pos.grid(True, alpha=0.3)
        
        # State rotation (rx, ry, rz)
        rot_labels = ['rx', 'ry', 'rz']
        for i in range(3):
            ax_state_rot.plot(time, data['states'][:, 3 + i], label=rot_labels[i], alpha=0.8)
        # Gripper
        ax_state_rot.plot(time, data['states'][:, 6], label='gripper', linestyle='--', alpha=0.8)
        state_rot_vline = ax_state_rot.axvline(x=0, color='r', linestyle='--', linewidth=2)
        ax_state_rot.set_xlabel('Step')
        ax_state_rot.set_ylabel('Angle / Gripper')
        ax_state_rot.set_title('State: Rotation + Gripper')
        ax_state_rot.legend(loc='upper right', fontsize=8)
        ax_state_rot.grid(True, alpha=0.3)
        
        # Action position (x, y, z)
        for i in range(3):
            ax_action_pos.plot(time, data['actions'][:, i], label=pos_labels[i], alpha=0.8)
        action_pos_vline = ax_action_pos.axvline(x=0, color='r', linestyle='--', linewidth=2)
        ax_action_pos.set_xlabel('Step')
        ax_action_pos.set_ylabel('Action')
        ax_action_pos.set_title('Action: Position (xyz)')
        ax_action_pos.legend(loc='upper right', fontsize=8)
        ax_action_pos.grid(True, alpha=0.3)
        
        # Action rotation (rx, ry, rz) + gripper
        for i in range(3):
            ax_action_rot.plot(time, data['actions'][:, 3 + i], label=rot_labels[i], alpha=0.8)
        ax_action_rot.plot(time, data['actions'][:, 6], label='gripper', linestyle='--', alpha=0.8)
        action_rot_vline = ax_action_rot.axvline(x=0, color='r', linestyle='--', linewidth=2)
        ax_action_rot.set_xlabel('Step')
        ax_action_rot.set_ylabel('Action')
        ax_action_rot.set_title('Action: Rotation + Gripper')
        ax_action_rot.legend(loc='upper right', fontsize=8)
        ax_action_rot.grid(True, alpha=0.3)
        
        return state_pos_vline, state_rot_vline, action_pos_vline, action_rot_vline
    
    # Initial plot
    state_pos_vline, state_rot_vline, action_pos_vline, action_rot_vline = plot_episode_data(episode_data[0])
    
    def update_episode_info():
        data = episode_data[0]
        info_str = f"""Episode: {current_episode_idx[0] + 1}/{n_episodes}
Frames: {len(data['images'])}
Source: {Path(data['file_path']).name}

Instruction:
{data['language_instruction']}"""
        episode_info_text.set_text(info_str)
    
    def update_frame_info(frame):
        data = episode_data[0]
        state = data['states'][frame]
        action = data['actions'][frame]
        info_str = f"""Frame: {frame}/{len(data['images'])-1}

State (7D):
  pos: [{state[0]:.3f}, {state[1]:.3f}, {state[2]:.3f}]
  rot: [{state[3]:.3f}, {state[4]:.3f}, {state[5]:.3f}]
  grip: {state[6]:.3f}

Action (7D):
  pos: [{action[0]:.4f}, {action[1]:.4f}, {action[2]:.4f}]
  rot: [{action[3]:.4f}, {action[4]:.4f}, {action[5]:.4f}]
  grip: {action[6]:.3f}"""
        info_text.set_text(info_str)
    
    def update_frame(frame):
        nonlocal state_pos_vline, state_rot_vline, action_pos_vline, action_rot_vline
        frame = int(frame)
        current_frame[0] = frame
        data = episode_data[0]
        
        # Update images
        im_img.set_data(data['images'][frame])
        im_wrist.set_data(data['wrist_images'][frame])
        
        # Update vertical lines
        state_pos_vline.set_xdata([frame, frame])
        state_rot_vline.set_xdata([frame, frame])
        action_pos_vline.set_xdata([frame, frame])
        action_rot_vline.set_xdata([frame, frame])
        
        update_frame_info(frame)
        fig.canvas.draw_idle()
    
    def load_episode(idx):
        nonlocal state_pos_vline, state_rot_vline, action_pos_vline, action_rot_vline
        current_episode_idx[0] = idx
        episode_data[0] = extract_episode_data(episodes[idx])
        
        # Update plots
        state_pos_vline, state_rot_vline, action_pos_vline, action_rot_vline = plot_episode_data(episode_data[0])
        
        # Update slider range
        n_frames = len(episode_data[0]['images'])
        frame_slider.valmax = n_frames - 1
        frame_slider.ax.set_xlim(0, n_frames - 1)
        frame_slider.set_val(0)
        
        # Update episode slider
        episode_slider.set_val(idx)
        
        update_episode_info()
        update_frame(0)
    
    # Add frame slider
    ax_frame_slider = fig.add_axes([0.15, 0.02, 0.5, 0.02])
    frame_slider = Slider(ax_frame_slider, 'Frame', 0, n_frames - 1, valinit=0, valstep=1)
    frame_slider.on_changed(update_frame)
    
    # Add episode slider
    ax_episode_slider = fig.add_axes([0.15, 0.05, 0.5, 0.02])
    episode_slider = Slider(ax_episode_slider, 'Episode', 0, n_episodes - 1, valinit=0, valstep=1)
    
    def on_episode_change(val):
        idx = int(val)
        if idx != current_episode_idx[0]:
            load_episode(idx)
    
    episode_slider.on_changed(on_episode_change)
    
    # Add play button
    ax_play = fig.add_axes([0.7, 0.02, 0.08, 0.03])
    play_button = Button(ax_play, 'Play')
    
    playing = [False]
    
    def toggle_play(event):
        playing[0] = not playing[0]
        play_button.label.set_text('Pause' if playing[0] else 'Play')
    
    play_button.on_clicked(toggle_play)
    
    # Animation
    def animate(event):
        if playing[0]:
            data = episode_data[0]
            next_frame = (current_frame[0] + 1) % len(data['images'])
            frame_slider.set_val(next_frame)
    
    timer = fig.canvas.new_timer(interval=100)  # 10 fps
    timer.add_callback(animate, None)
    timer.start()
    
    # Initial info update
    update_episode_info()
    update_frame_info(0)
    
    plt.tight_layout()
    plt.subplots_adjust(bottom=0.1)
    plt.show()


def save_video(episodes: list, output_path: str, fps: int = 10, max_episodes: int = None):
    """Save episodes as a video file."""
    try:
        import cv2
    except ImportError:
        print("OpenCV not installed. Install with: pip install opencv-python")
        return
    
    if max_episodes is not None:
        episodes = episodes[:max_episodes]
    
    # Determine output size (side by side images)
    sample = extract_episode_data(episodes[0])
    h, w = sample['images'][0].shape[:2]
    total_w = w * 2  # Two images side by side
    
    # Create video writer
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(output_path, fourcc, fps, (total_w, h + 40))  # Extra height for text
    
    print(f"Saving video to {output_path}...")
    
    for ep_idx, episode in enumerate(episodes):
        data = extract_episode_data(episode)
        n_frames = len(data['images'])
        
        print(f"  Episode {ep_idx + 1}/{len(episodes)}: {n_frames} frames")
        
        for i in range(n_frames):
            # Create frame with text area
            frame = np.zeros((h + 40, total_w, 3), dtype=np.uint8)
            
            # Add images side by side
            frame[40:, :w] = data['images'][i]
            frame[40:, w:] = data['wrist_images'][i]
            
            # Convert RGB to BGR for OpenCV
            frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            
            # Add text
            cv2.putText(frame_bgr, f'Ep {ep_idx+1}/{len(episodes)} Frame {i}/{n_frames-1}',
                       (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 1)
            cv2.putText(frame_bgr, f'Task: {data["language_instruction"][:50]}',
                       (300, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200, 200, 200), 1)
            
            out.write(frame_bgr)
    
    out.release()
    print(f"Video saved to {output_path}")


def print_dataset_info(dataset_path: str):
    """Print information about the dataset."""
    builder = tfds.builder_from_directory(dataset_path)
    info = builder.info
    
    print(f"\nDataset: {info.name}")
    print(f"Version: {info.version}")
    print(f"Description: {info.description}")
    print(f"\nFeatures:")
    print(info.features)
    print(f"\nSplits:")
    for split_name, split_info in info.splits.items():
        print(f"  {split_name}: {split_info.num_examples} episodes")


def main():
    parser = argparse.ArgumentParser(description='Visualize RLDS dataset')
    parser.add_argument('dataset_path', type=str, 
                        help='Path to the TFDS dataset directory (e.g., ~/tensorflow_datasets/franka_dataset/1.0.0/)')
    parser.add_argument('--split', type=str, default='train',
                        help='Dataset split to visualize (default: train)')
    parser.add_argument('--save-video', type=str, default=None,
                        help='Save as video to the specified path')
    parser.add_argument('--fps', type=int, default=10,
                        help='FPS for saved video (default: 10)')
    parser.add_argument('--max-episodes', type=int, default=None,
                        help='Maximum number of episodes for video (default: all)')
    parser.add_argument('--info', action='store_true',
                        help='Print dataset info and exit')
    args = parser.parse_args()
    
    dataset_path = str(Path(args.dataset_path).expanduser())
    
    if not Path(dataset_path).exists():
        print(f"Error: Dataset path not found: {dataset_path}")
        return
    
    if args.info:
        print_dataset_info(dataset_path)
        return
    
    print(f"Loading dataset from {dataset_path}...")
    ds = load_rlds_dataset(dataset_path, args.split)
    
    # Convert to list for random access
    print("Loading episodes into memory...")
    episodes = list(ds)
    print(f"Loaded {len(episodes)} episodes")
    
    if args.save_video:
        save_video(episodes, args.save_video, args.fps, args.max_episodes)
    else:
        create_interactive_viewer(episodes, dataset_path)


if __name__ == '__main__':
    main()
